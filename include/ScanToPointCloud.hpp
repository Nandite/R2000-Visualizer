// Copyright (c) 2022 Papa Libasse Sow.
// https://github.com/Nandite/R2000-Visualizer
// Distributed under the MIT Software License (X11 license).
//
// SPDX-License-Identifier: MIT
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
// the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#pragma once

#include <vector>
#include "DataLink/Data.hpp"
#include <pcl/point_cloud.h>

namespace PointCloud {
    /**
     * @brief This class allows to convert raw data incoming from a P&F R2000 sensor to a point cloud for a fixed
     * set of parameters of the sensor.
     * @date 03/02/2020
     */
    template<typename PointT>
    class ScanToPointCloud {

    public:
        /**
         * @brief Construct a new instance of this converter with a given set of parameters used by the P&F sensor.
         * @param N The number of points provided by the sensor for each scan.
         * @param thetaMin The minimal angle between each point of the scan.
         * @date 03/02/2020
         */
        ScanToPointCloud(const unsigned int N, const float thetaMin)
                : mCosines(new std::vector<float>),
                  mSinuses(new std::vector<float>),
                  nbPoints(N) {
            mCosines->reserve(nbPoints);
            mSinuses->reserve(nbPoints);
            const auto increment = float(2.0f * M_PI / nbPoints);
            for (unsigned int i = 0; i < nbPoints; ++i) {
                const float angle = thetaMin + (increment * float(i));
                sincosf(angle, &((*mSinuses)[i]), &((*mCosines)[i]));
            }
        }

        /**
         * @brief Convert a raw scan from a P&F R2000 to a point cloud. The
         * @param scan the raw scan from the sensor.
         * @param indices Indices of the points kept and inserted into the output cloud.
         * @param cloud Output cloud generated from the raw scan.
         * @date 03/02/2020
         */
        void convert(const Device::Data::Scan &scan, typename pcl::PointCloud<PointT> &cloud) {
            cloud.reserve(nbPoints);
            const auto &distances{scan.getDistances()};
            auto index{0u};
            for (const auto &range : distances) {
                if (std::isnan(range))
                    continue;
                PointT point{};
                point.x = float(range) * (*mCosines)[index];
                point.y = float(range) * (*mSinuses)[index];
                point.z = 0.0f;
                cloud.push_back(point);
                ++index;
            }
        }

        /**
         * @brief Trivial Dtor.
         * @date 03/02/2020
         */
        virtual ~ScanToPointCloud() = default;

    private:
        /**
         * Cosines of the points generated by the sensor. Depending on the minimal theta
         * between each point configured on the sensor, every points generated around the sensor
         * lie at a specific angle whose cosine can be looked up in this vector depending on the
         * index of the point.
         */
        std::unique_ptr<std::vector<float>> mCosines{nullptr}; //!< preprocessed cosines
        /**
         * Sinuses of the points generated by the sensor. Depending on the minimal theta
         * between each point configured on the sensor, every points generated around the sensor
         * lie at a specific angle whose sinus can be looked up in this vector depending on the
         * index of the point.
         */
        std::unique_ptr<std::vector<float>> mSinuses{nullptr}; //!< preprocessed sines
        /**
         * Number of point the sensor is parameterized to return for each scan.
         */
        const unsigned int nbPoints{};
    };
}
